\chapter{Desenvolvimento}

O MTA, como extensão de um processo de desenvolvimento de \textit{software}, não
especifica qual é a maneira correta de executar as tarefas e atividades
propostas. É um desafio partir dos requisitos de acessibilidade e conseguir
entregar um produto acessível. Por isso, é fundamental haver um método de
rastreabilidade desses requisitos, de forma que exista uma garantia a
implementação está sendo feito de forma correta.

Os requisitos de acessibilidade devem ser propagados desde o início do processo
(levantamento e confecção do documento de requisitos) até as etapas finais de
codificação e testes de forma consistente.

Para o trabalho proposto, definimos como escopo apenas os subprocessos 4
(Análise de Requisitos de Software), 5 (Projeto de Software) e 6 (Construção do
Software) e suas respectivas tarefas de acessibilidade. As tarefas de testes,
presentes no subprocesso 6 não serão levadas em consideração.

Essa abordagem foi adotada pois, embora as definições de acessibilidade já
começam no subprocesso 1, é no subprocesso 4 que os requisitos são ``lapidados''
e o artefato de entrada das fases de projeto é gerado.

A seguir, mostraremos como relacionar os subprocessos citados com o rastreio dos
requisitos de acessibilidade.

\section{Entendimento do problema}

O especialista em acessibilidade é fundamental em todas as etapas descritas a
seguir, como já reforça o modelo MTA. Ele deve ter a experiência e maturidade
para capturar os requisitos de acessibilidade no momento conveniente. Isso pode
ocorrer (e é desejável) no levantamento de requisitos de forma explícita
(sugerindo possivelmente um requisito funcional), de forma genérica e não
específica (sugerindo possivelmente um requisito não funcional) ou não aparecer.

Requisitos funcionais e não funcionais são abordados no subprocesso 4, ponto de
partida deste trabalho no modelo MTA. Caso os requisitos não sejam identificados
nesta etapa, o especialista de acessibilidade deverá, no subprocesso 5,
especificar nos projetos de interface e navegação os itens que merecem um
tratamento de acessibilidade específico.

\section{Subprocesso 4 - Análise de Requisitos de Software}
\label{linktocase}

O objetivo do subprocesso 4 é estabelecer os requisitos dos elementos de
software do sistema. Elementos aqui são considerados interface e código
\citep{maia:10}.

O MTA insere duas tarefas de acessibilidade, conforme mostrado na figura
\ref{fig:sub4}.

\begin{figure}[ht] \centering
\includegraphics[width=.8\textwidth,height=200px]{./images/subprocesso4.png}
\caption{Tarefas para o subprocesso de análise de requisitos do software
\citep{maia:10}}
\label{fig:sub4}
\end{figure}

É importante ressaltar que os requisitos já são parcialmente coletados em
subprocessos anteriores, mas é apenas nesse subprocesso que os requisitos de
interface e código são considerados. É nesse subprocesso também que irá originar
o artefato para as fases de projeto e codificação.

 A saída da tarefa \textbf{Avaliar os requisitos de acessibilidade de software}
 (Documento de requisitos de acessibilidade do software avaliados e aprovados)
 passa por um tratamento, gerando um novo artefato. A proposta é que mais um
 artefato seja gerado, sendo um documento de requisitos em um formato legível
 por máquina, não ambiguo e que possa ser gerenciado por uma ferramenta
 \gls{case}, que será utilizado nos passos subsequentes para rastreamento dos
 requisitos de acessibilidade. A escolha adotada neste trabalho é o formato
 XMI/XML, principalmente por ser o principal formato para descrever elementos
 \gls{uml}. A partir de agora, apesar de ser possível a utilização de outros
 formatos para atingir o mesmo objetivo, devido as características deste
 trabalho bem como das ferramentas utilizadas que serão elencadas
 posteriormente, o formato XMI/XML será o formato utilizado para descrever os
 artefatos aqui definidos.
 
 A ferramenta \gls{case} pode gerar o esqueleto da matriz de rastreabilidade
 para os requisitos de acessibilidade. A matriz de rastreabiliade é um método
 estático para rastreabilidade de requisitos
 \citep{guo:2009:OBI:1681515.1682933}. Embora exista métodos dinâmicos
 \citep{Cleland-Huang:2005:USE:1099549.1100625}, estes não são considerados
 neste trabalho. Conforme os artefatos vão sendo gerados/atualizados, a matriz
 pode ser gerada para adequar ao quadro atual do projeto.
 
 Embora existam iniciativas de transformar um documento de requisitos em
 linguagem natural para artefatos \gls{uml} \citep{trove.nla.gov.au/work/7376771} através de ferramentas automatizadas
 \citep{Deeptimahanti:2009:ATG:1747491.1747583,Kumar:2008:SUM:1487741.1488136},
 essa abordagem não será utilizada, exigindo que o especialista em
 acessibilidade faça os lançamentos manuais na ferramenta \gls{case}.
 
 A \gls{uml} normalmente é utilizada para discriminar os artefatos posteriores
 ao documento de requisitos, como casos de uso, diagramas de classe, diagramas
 de sequência, diagramas de atividade, entre outros. É comum que tais diagramas
 sejam descritos, através de ferramentas \gls{case}, em XML. Portanto, é
 possível utilizar um elemento \gls{uml} não intrusivo nos artefatos para
 associar os requisitos ao elemento alvo do artefato. O elemento em questão é a
 \textit{Nota} (ou anotações)
\footnote{http://www.agilemodeling.com/style/note.htm}, que não possui nenhum
 valor semântico real para o modelo, mas serve para adicionar mais informações
 sobre um objeto ou situação específica e pode ser ancorada a um elemento
 \gls{uml} para mostrar que tal nota está associada ao contexto específico. É possível verificar
 a utilização de notas \gls{uml} para rastreabilidade no trabalho de \citet{Joonhoon:09}, apesar do contexto
 ser diferente. 
 
 Definindo uma sintaxe para as notas, é possível associar os elementos \gls{uml}
 dos artefatos aos requisitos.
 A princípio, isso pode ser feito de duas formas:
 
 \begin{enumerate}
   \item A ferramenta \gls{case} descrita leria os modelos (XML), efetuaria o \textit{parser} e incluiria as notas 
   no arquivo XML;
   \item O especialista em acessibilidade, através de ferramentas próprias de modelagem utilizadas no projeto, incluiria
   as notas, que posteriormente seriam associados utilizando a ferramenta \gls{case} descrita anteriormente.
 \end{enumerate}
 
 O principal problema da primeira abordagem é que as ferramentas de modelagem
 geram modelos \gls{uml} com formato \gls{xml} variado e quase sempre
 incompatíveis, isso quando permitem a exportação do modelo para o formato
 \gls{xml} (Os arquivos analisados foram gerados pelas ferramentas
 \textit{Astash Professional}\footnote{http://astah.net/download},
 \gls{emf}\footnote{http://www.eclipse.org/modeling/emf/} e \textit{Visual
 Paradigm}\footnote{http://www.visual-paradigm.com/}).
 Assim, a ferramenta \gls{case} precisa se especializar em uma ou mais ferramentas de modelagem específicas, uma abordagem desafiadora, devido a
 quantidade de ferramentas de modelagem disponíveis no mercado. O problema da
 segunda abordagem é que o especialista de acessibilidade precisa utilizar a
 ferramenta \gls{case} de modelagem e incluir as notas na sintaxe específica.
 Contudo, essa é maneira que menos pertuba os modelos e os mantém íntegros,
 portanto, essa será a forma abordada neste trabalho.
 
 
 \section{Subprocesso 5 - Projeto de Software}
 
 O objetivo do subprocesso 5 é fornecer um projeto onde os requisitos do
 software possam ser implementados e verificados \citep{maia:10}.
 
 O MTA insere três tarefas de acessibilidade, conforme mostrado na figura
\ref{fig:sub5}.

\begin{figure}[ht]
\centering
\includegraphics[width=.8\textwidth,height=200px]{./images/subprocesso5.png}
\caption{Tarefas para o subprocesso de projeto de software \citep{maia:10}}
\label{fig:sub5}
\end{figure}

As três tarefas deste subprocesso são de extrema importância, e impactam
diretamente na acessibilidade do produto final. O artefato XML/XMI gerado no
subprocesso anterior passará por cada tarefa deste subprocesso, de forma que,
além da saída da tarefa \textbf{Avaliar a acessibilidade do projeto de software}
gerar o artefato Projeto de software acessível, esta tarefa também gerará um
artefato de projeto de software no formato XML/XMI, com elementos de
acessibilidade embutidos.

A proposta deste trabalho enseja que as subtarefas das tarefas pertencentes a
esse subprocesso já começam a contar com critérios de sucesso do WCAG 2.0. Desta
forma, torna-se mais fácil relacionar os pontos críticos de acessibilidade do
projeto de interface e navegação nos passos posteriores, principalmente porque
um software automatizado não consegue fazer algumas verificações levando em
consideração o contexto semântico (por exemplo, ordem de navegação).

Além disso, é necessário esclarecer que o padrão de conformidade para o projeto
é definido na tarefa 1.1 do subprocesso 1. Contudo, os padrões e ferramentas
disponíveis levam em consideração o reconhecido padrão WCAG 2.0. Portanto, ferramentas que seguem
o padrão WCAG 2.0 deveriam ser acessíveis, mas a necessidade de conformidade com
outros padrões leva a necessidade de um monitoramento constante por parte do
especialista em acessibilidade.

O especialista em acessibilidade deve associar os elementos de interface e
navegação, através da ferramenta \gls{case}, os requisitos provenientes da etapa
anterior. Além disso é possível mapear, se aplicável, técnicas de implementação
de acessibilidade.

Um projeto útil para essa finalidade é \textit{AEGIS Ontology}
\footnote{http://www.aegis-project.eu/index.php?option=com\_content\&view=article\&id=107\&Itemid=65},
que define ontologias de acessibilidade na \textit{Web}. O principal objetivo do
projeto é mapear os conceitos de acessibilidade, e como eles podem ser mapeados
dentro de um cenário de acessibilidade.

O projeto é apoiado pelo \textit{Accessible Consortium}
\footnote{http://www.accessible-eu.org/index.php/consortium.html}, que
disponibiliza uma página para a consulta das novidades da iniciativa
\footnote{http://www.accessible-eu.org/index.php/ontology.html}. A versão atual
é a 5.1

As ontologias são descritas no formato \gls{owl}, padrão definido pela \gls{w3c}
em 2004\footnote{http://www.w3.org/TR/owl-features/}, que está na versão 1.0
mas já possui uma versão candidata à 2.0, lançada em 2012
\footnote{http://www.w3.org/TR/owl2-overview/}. As ontologias descritas aqui
estão no padrão 1.0.

O projeto vai além de realizar o mapeamento dos conceitos de acessibilidade e
cenários. Os arquivos disponibilizados mapeam o modelo WCAG 2.0 (incluindo
técnicas de implementação, critérios de sucesso e falha, etc), leitores de tela,
navegadores textuais, lentes de aumento, WAI/ARIA, entre outros. É possível
navegar pelas ontologias via navegador
\footnote{http://160.40.50.89/Accessible\_Ontology/Version5.1/AccessibleOntologyOWLDoc/index.html},
ou explorar os arquivos confortavelmente através do software \textit{Protegé}
\citep{Noy01creatingsemantic}.

Ao final deste subprocesso, a ferramenta \gls{case} já deve ter as associações dos requisitos de acessibilidade com os
itens de interface e navegação (já incluindo a associação com o WCAG 2.0), bem como os outros artefatos modelados 
no subprocesso anterior. A matriz de rastreabilidade pode ser gerada novamente, dessa vez mais completa.

\section{Subprocesso 6 - Construção do Software}

 O objetivo do subprocesso 6 é produzir unidades de software executáveis que
 apropriadamente refletem o projeto de software \citep{maia:10}.
 
 O MTA insere quatro tarefas de acessibilidade, conforme mostrado na figura
\ref{fig:sub6}.

\begin{figure}[ht]
\centering
\includegraphics[width=.8\textwidth,height=350px]{./images/subprocesso6.png}
\caption{Tarefas para o subprocesso de construção do software \citep{maia:10}}
\label{fig:sub6}
\end{figure}

A tarefa 6.1 (Especificar Técnicas para Implementação da Acessibilidade da
Interface e do Código) visa explicitar as técnicas de implementação de
acessibilidade, refletidas no projeto de software. Como dito anteriormente, o
padrão de conformidade já deve ter sido escolhido no subprocesso 1. Apesar dos padrões
de acessibilidade serem diferentes em essência, existe uma grande intersecção no que se
refere as técnicas utilizadas para implementação efetiva da acessibilidade no produto.
As regras para implementação do padrão e-Mag 3.0 são muito parecidas com as do padrão WCAG 2.0,
e a tendência é que haja uma homogeneização dos esforços em desenvolver produtos acessíveis, principalmente
como a evolução do \gls{html} 5. 

Os modelos WCAG 2.0 e e-Mag 3.0 já possuem técnicas de acessibilidade presentes
em seus respectivos documento. Esse é o momento de relacionar as especificidades do projeto de
software com as técnicas de acessibilidade do modelo escolhido. Caso nenhum
modelo conhecido ou algum modelo não usual tenha sido escolhido, as técnicas de
implementação de acessibilidade deverão ser explicitamente relacionadas no
projeto, o que não pode ser uma atividade fácil.

Por conveniência, as técnicas utilizadas serão as do WCAG 2.0, pelo fato de já estarem mapeadas nos arquivos
\gls{owl} descritos anteriormente.

Pelo contexto do trabalho, apesar de extrema importância, as tarefas
\textbf{Planejar teste de acessibilidade para cada unidade de software} e
\textbf{Executar teste de acessibilidade de cada unidade de software} não foram
consideradas.

A tarefa 6.2 (Codificar e documentar cada unidade de software de acordo com as
técnicas de acessibilidade) recebe benefícios diretos dos passos anteriores,
pois o projeto já contém os pontos críticos de acessibilidade explicitados. 
Ferramentas case, neste ponto, comumente geram código (\textit{stub}\footnote{http://en.wikipedia.org/wiki/Method\_stub}), 
utilizando artefatos como diagramas de classe, de sequência e casos de uso. O código
gerado já poderia conter traços de documentação associados aos requisitos de acessibilidade.
Uma maneira imediata de documentar código é adicionando comentários padronizados, de forma que os requisitos
de acessibilidade possam ser localizados.

Para incorporar a rastreabilidade
dos requisitos no código gerado pelas ferramentas em forma de comentário de código, temos as seguintes abordagens:

\begin{enumerate}
  \item A ferramenta de modelagem gera os códigos, e a partir destes, a ferramenta \gls{case} proposta incluiria os comentários
  de rastreabilidade;
  \item A ferramenta \gls{case} proposta substituiria o gerador de código, realizando todo o trabalho e gerando o código já documentado.
\end{enumerate}

Como implementar uma nova ferramenta de geração de código foge do escopo deste
trabalho, a primeira abordagem se mostrou mais atraente.

\section{Escolha das Ferramentas e Tecnologias}

A proposta deste trabalho é demonstrar a rastreabilidade dos requisitos de
acessibilidade no processo de desenvolvimento de \textit{software},
independente de ferramenta ou tecnologia adotada pelos analistas e
desenvolvedores.

Já existem iniciativas, principalmente corporativas, que permitem agregar aos
artefatos do processo de desenvolvimento os requisitos levantados.
\citet{hovater:08} mostra como construir relatórios de rastreabilidade usando os
programas \textit{IBM Rational Software Architect}\footnote{http://www-142.ibm.com/software/products/br/pt/ratisoftarch/},
\textit{IBM Rational RequisitePro}\footnote{http://www-142.ibm.com/software/products/br/pt/reqpro/} e \gls{birt}
para \textit{WebSphere}\footnote{http://www-01.ibm.com/software/websphere/}.

O software \textit{Enterprise Architect} da empresa \textit{Sparx Systems}\footnote{http://www.sparxsystems.com/enterprise\_architect\_user\_guide/index.html}
permite utilizar diagramas de requisitos\footnote{http://www.sparxsystems.com/enterprise\_architect\_user\_guide/modeling\_languages/requirements\_diagram.html},
que são extensões dos diagramas tradicionais da \gls{uml}, permitindo a
rastreabilidade do
modelo\footnote{http://www.sparxsystems.com/enterprise\_architect\_user\_guide/navigate\_search\_and\_trace/traceability.html}.
Contudo, não foi encontrado na literatura trabalhos que tratem especificamente
da rastreabilidade dos requisitos de acessibilidade dentro do processo de um
desenvolvimento de \textit{software}.

Dessa forma, para demonstrar a proposta deste trabalho, construiremos uma
ferramenta \gls{case}, nos moldes descritos na seção \ref{linktocase}. A seguir
é elencado os principais elementos usados para a demostração deste trabalho.

\begin{itemize}
  \item \gls{mta} - Processo de Desenvolvimento de \textit{Software} acessível
  \item \textit{Eclipse Juno} - \gls{ide}
  \item \textit{Requirement Designer v0.8.0}\footnote{http://marketplace.eclipse.org/node/407399\#.UR43GaXC1VJ} - 
  \textit{plugin} de gerenciamento de
  requisitos
  \item \textit{UML Designer v2.1.0}\footnote{http://marketplace.eclipse.org/content/uml-designer-indigo-version\#.UR43OaXC1VI} - 
  \textit{plugin} de modelagem \gls{uml}
  \item \textit{UML to Java Generator v1.0.2}\footnote{http://marketplace.eclipse.org/content/uml-java-generator\#.UR44XKXC1VI} - 
  \textit{plugin} de geração de código 
  \item \textit{Java JRE7 e JDK1.7}\footnote{http://www.oracle.com/technetwork/java/index.html} 
  - Linguagem para desenvolvimento de \textit{plugins} e código final do produto
  \item Ontologias para implementação das diretrizes do \gls{wcag} 2.0.
\end{itemize}

O \textit{Eclipse} é uma plataforma madura e foi escolhido como \gls{ide} por
vários motivos. Ele serve como base para para diversos produtos e tecnologias baseadas em uma \gls{ide},
provendo uma \gls{api} para facilitar a integração \citep{5386785}.
O desenvolvimento de \textit{plugins} para o \textit{Eclipse} é feito diretamente na \gls{ide}, de forma prática e 
transparente\footnote{Um tutorial de desenvolvimento de plugins para o Eclipse
pode ser encontrado em http://www.ibm.com/developerworks/br/library/os-ecplug/}, tendo ampla documentação a respeito. 
A linguagem utilizada para o desenvolvimento do \textit{plugin} é linguagem \textit{Java}, assim como o código gerado 
pelo \textit{plugin} de exportação.

O pacote de modelagem inicialmente instalado foram os \textit{plugins} \gls{emf} propostos pelo \textit{Eclipse}, notadamente
o \textit{Ecore Tools}\footnote{http://www.eclipse.org/modeling/emft/?project=ecoretools}, parte integrante do \gls{emft}. Contudo,
os diagramas fornecidos por \textit{default} não satisfizeram aos anseios de modelagem, pois não contemplavam diagramas de sequência ou de 
casos de uso, por exemplo. Por esse motivo, o \textit{plugin} escolhido foi o \textit{UML Designer}, que utiliza como base o pacote \gls{emf} (portanto gera modelos \gls{emf}), 
mas extende os modelos existentes para que se adequem aos modelos \gls{uml} na sua versão 2.4. 

O \textit{plugin} inicialmente escolhido para o gerenciamento de requisitos foi o \textit{ProR}\footnote{http://www.eclipse.org/rmf/pror/},
que por sua vez é parte do projeto \gls{rmf} e \gls{emf} do \textit{Eclipse}. O objetivo do projeto \gls{rmf} é implementar o 
padrão \textit{OMG ReqIF}\footnote{http://www.omg.org/spec/ReqIF/}
em forma de modelos \gls{emf}. Contudo, o \gls{rmf} se encontra atualmente na 0.6.0, e o \textit{plugin} não fornecia a 
funcionalidade de ligação entre os modelos e os requisitos. Assim, modos alternativos de relacionamento entre os modelos e os requisitos
deveriam ser implementados, tornando inviável o desenvolvimento do trabalho. Portanto, o \textit{plugin} escolhido para o gerenciamento
de requisitos foi o \textit{Requirement Designer}, que permite realizar a associação dos requisitos com qualquer modelo \gls{emf}.

Os \textit{plugins} de modelagem e gerenciamento de requisitos são desenvolvidos pela \textit{Obeo}\footnote{http://www.eclipse.org/membership/showMember.php?member\_id=863},
portanto, para permitir uma integração suave entre as ferramentas, o \textit{plugin} escolhido para geração de código foi o 
\textit{UML to Java Generator}, desenvolvido pela mesma empresa. Os \textit{plugins} são disponibilizados sob a licença \textit{Eclipse Public License v
1.0}\footnote{http://www.eclipse.org/legal/epl-v10.html}, assim como a própria \gls{ide}. Dessa forma, é possível
estudar, alterar e customizar seus componentes para atingir aos objetivos do trabalho.

