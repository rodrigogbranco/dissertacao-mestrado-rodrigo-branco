\chapter{Integração de Requisitos de Acessibilidade ao Processo de Desenvolvimento de \textit{Software}}

O MTA, como extensão de um processo de desenvolvimento de \textit{software}, não
especifica qual é a maneira correta de executar as tarefas e atividades
propostas. É um desafio partir dos requisitos de acessibilidade e conseguir
entregar um produto acessível. Por isso, é fundamental haver um método de
rastreabilidade desses requisitos, de forma que exista uma garantia de que a
implementação está sendo feito de forma correta.

Os requisitos de acessibilidade devem ser propagados desde o início do processo
(levantamento e confecção do documento de requisitos) até as etapas finais de
codificação e testes de forma consistente.

Para o trabalho proposto, foi definido como escopo apenas os subprocessos 4
(Análise de Requisitos de Software), 5 (Projeto de Software) e 6 (Construção do
Software) e suas respectivas tarefas de acessibilidade propostas no \gls{mta}. Essa abordagem foi adotada pois, embora as definições de acessibilidade já
comecem no subprocesso 1, é no subprocesso 4 que os requisitos são ``lapidados''
e o artefato de entrada das fases de projeto é gerado.

As tarefas de testes,
presentes no subprocesso 6, não serão levadas em consideração.

A seguir, serão apresentados os relacionamentos entre os subprocessos citados
com o rastreio dos requisitos de acessibilidade.

\section{Subprocesso 4 - Análise de Requisitos de Software}
\label{linktocase}

O especialista em acessibilidade é fundamental em todas as etapas descritas a
seguir, como já reforça o modelo MTA. O especialista em acessibilidade deve
conseguir identificar requisitos funcionais e não funcionais de acessibilidade. O requisito de
acessibilidade pode não ser encontrado explicitamente neste momento, mas a identificação posterior 
exigirá um refatoramento do modelo.

Requisitos funcionais e não funcionais são abordados no subprocesso 4, ponto de
partida deste trabalho no modelo MTA. Caso os requisitos não sejam identificados
nesta etapa, o especialista em acessibilidade deverá, no subprocesso 5,
especificar nos projetos de interface e navegação os itens que merecem um
tratamento de acessibilidade específico.

O objetivo do subprocesso 4 é estabelecer os requisitos dos elementos de
software do sistema. Elementos aqui são considerados interface e código
\citep{maia:10}.

O MTA insere duas tarefas de acessibilidade, conforme mostrado na Figura
\ref{fig:sub4}.

\begin{figure}[htbp] \centering
\includegraphics[width=.8\textwidth,height=200px]{./images/subprocesso4.png}
\caption{Tarefas para o subprocesso de análise de requisitos do software
\citep{maia:10}}
\label{fig:sub4}
\end{figure}

É importante ressaltar que os requisitos já são parcialmente coletados em
subprocessos anteriores, mas é apenas nesse subprocesso que os requisitos de
interface e código são considerados. É nesse subprocesso também que irá originar
o artefato para as fases de projeto e codificação.

 A saída da tarefa \textbf{Avaliar os requisitos de acessibilidade de software}
 é processada, gerando um novo artefato (Documento de requisitos de acessibilidade do software avaliados e aprovados). 
 Neste trabalho, propõe-se que mais um artefato seja gerado, sendo um documento de requisitos em um formato legível
 por máquina, não ambíguo e que possa ser gerenciado por uma ferramenta
 \gls{case}, que será utilizado nos passos subsequentes para rastreamento dos
 requisitos de acessibilidade. Foi adotado neste trabalho o formato
 XMI/XML, principalmente por ser o principal formato para descrever elementos
 \gls{uml}. Apesar de ser possível a utilização de outros
 formatos para atingir o mesmo objetivo, devido as características deste
 trabalho bem como das ferramentas utilizadas que serão elencadas
 posteriormente, o formato XMI/XML será o formato utilizado para descrever os
 artefatos definidos neste trabalho.
 
É importante definir como os requisitos serão rastreados dentro do processo
 de desenvolvimento. O método de rastreabilidade
 utilizado será uma matriz de rastreabiliade de requisitos
 \citep{guo:2009:OBI:1681515.1682933}. Conforme os artefatos vão sendo
 gerados/atualizados, a matriz também é gerada e atualizada para adequar ao quadro atual do projeto. A ferramenta \gls{case} pode gerar o esqueleto da matriz de rastreabilidade
 para os requisitos de acessibilidade.
 
 O método prosposto pode ser classificado como um método estático de
 rastreabilidade. Embora existam métodos dinâmicos
 \citep{Cleland-Huang:2005:USE:1099549.1100625}, para estes métodos, mudanças no
 artefatos refletem mudanças na matriz. Como neste trabalho nem todos os
 artefatos são utilizados, e é necessário gerar explicitamente a matriz através
 de um comando do \textit{Eclipse}, métodos dinâmicos não serão considerados.
 
 A \gls{uml} normalmente é utilizada para discriminar os artefatos posteriores
 ao documento de requisitos, como casos de uso, diagramas de classe, diagramas
 de sequência, diagramas de atividade, entre outros. É comum que tais diagramas
 sejam descritos, através de ferramentas \gls{case}, em XML. Portanto, é
 possível utilizar o estereótipo textual \textit{Nota} da \gls{uml} para associar os
 requisitos aos elementos dos artefatos \gls{uml}.
 As notas não possuem valor semântico real para o modelo, mas servem para adicionar mais informações
 sobre um objeto ou situação específica e podem ser ancoradas a um elemento
 \gls{uml} para mostrar que tal nota está associada a um contexto específico. É possível verificar
 a utilização de notas \gls{uml} para rastreabilidade no trabalho de \citet{Joonhoon:09}, apesar do contexto
 ser diferente. 
 
 Definindo uma sintaxe para as notas é possível associar os elementos \gls{uml}
 dos artefatos aos requisitos.
 A princípio, isso pode ser feito de duas formas:
 
 \begin{enumerate}
   \item A ferramenta \gls{case} leria os modelos (XML), efetuaria o \textit{parser} e incluiria as notas 
   no arquivo XML;
   \item O especialista em acessibilidade, através de ferramentas próprias de modelagem utilizadas no projeto, incluiria
   as notas, que posteriormente seriam associados utilizando a ferramenta \gls{case} descrita anteriormente.
 \end{enumerate}
 
 O principal problema da primeira abordagem é que as ferramentas de modelagem
 geram modelos \gls{uml} com formato \gls{xml} variado e quase sempre
 incompatíveis, isso quando permitem a exportação do modelo para o formato
 \gls{xml} (Os arquivos analisados durante o desenvolvimento deste trabalho para se obter esta conclusão foram gerados pelas ferramentas
 \textit{Astash Professional} \citep{astah:13},
 \gls{emf} \citep{emf:13} e
 \textit{Visual Paradigm} \citep{visualparadigm:13}).
 Assim, seria preciso considerar uma ou mais ferramentas de modelagem
 específicas devido a quantidade de ferramentas de modelagem disponíveis no mercado. O problema da
 segunda abordagem é que o especialista de acessibilidade precisa utilizar a
 ferramenta \gls{case} de modelagem e incluir as notas na sintaxe específica.
 
 Uma alternativa à utilização de notas é a utilização de um arquivo externo de
 mapeamento entre os requisitos e os modelos. É uma abordagem relativamente
 simples se a estrutura dos arquivos de requisitos e dos modelos for
 previamente conhecida. Assim, é possível associar os requisitos utilizando os
 identificadores da estrutura (por exemplo, se os arquivos forem \gls{rdf}, é
 possível utilizar o atributo \textit{rdf:ID}). É possível também que a
 ferramenta de gerenciamento de requisitos permita que se faça a associação dos
 requisitos e dos modelos, caso a ferramenta conheça a descrição interna dos
 modelos.
 Esta abordagem foi utilizada neste trabalho: os \textit{plugins} utilizados para o
 gerenciamento de requisitos e modelagem utilizam a formatação de arquivos do \gls{emf}, que por sua vez são baseados no \gls{rdf}, sendo
 portanto compatíveis entre si.
 
 \section{Subprocesso 5 - Projeto de Software}
 
 O objetivo do subprocesso 5 é fornecer um projeto onde os requisitos do
 software possam ser implementados e verificados \citep{maia:10}.
 
 O MTA insere três tarefas de acessibilidade, conforme mostrado na Figura
\ref{fig:sub5}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth,height=200px]{./images/subprocesso5.png}
\caption{Tarefas para o subprocesso de projeto de software \citep{maia:10}}
\label{fig:sub5}
\end{figure}

As três tarefas deste subprocesso são de extrema importância, e impactam
diretamente na acessibilidade do produto final. O artefato XML/XMI gerado no
subprocesso anterior passará por cada tarefa deste subprocesso, de forma que,
além da saída da tarefa \textbf{Avaliar a acessibilidade do projeto de software}
e gerar o artefato \textbf{Projeto de software acessível}, esta tarefa também
gerará um artefato de projeto de software no formato XML/XMI, com elementos de
acessibilidade embutidos.

A proposta deste trabalho enseja que as subtarefas das tarefas pertencentes a
esse subprocesso já comecem a contar com critérios de sucesso do documento de
diretrizes de acessibilidade escolhido.
Desta forma, torna-se mais fácil relacionar os pontos críticos de acessibilidade do
projeto de interface e navegação nos passos posteriores, principalmente porque
um software automatizado não consegue fazer algumas verificações levando em
consideração o contexto semântico (por exemplo, ordem de navegação), e esses
pontos críticos devem ser revisados posteriormente.

Além disso, é necessário esclarecer que o padrão de conformidade para o projeto
é definido na tarefa 1.1 do subprocesso 1 (Elicitação dos Requisitos do
Sistema). Os padrões e ferramentas disponíveis levam em consideração o
reconhecido padrão WCAG 2.0. Contudo, a necessidade de conformidade com
outros padrões de acessibilidade leva a necessidade de um
monitoramento constante por parte do especialista em acessibilidade, pois nem sempre as
técnicas para a implementação do que é cobrado no padrão estão disponíveis (por
exemplo, é possível que um \textit{software} precise estar em conformidade com o
modelo \textit{Section 508}, mas esse padrão não explicita o que deve ser
feito para que o nível de acessibilidade pretendido seja alcançado).

O especialista em acessibilidade deve associar os elementos de interface e
navegação, utilizando da ferramenta \gls{case} aos requisitos
provenientes da etapa anterior. Além disso é possível mapear, se aplicável, técnicas de implementação
de acessibilidade.

Um projeto útil para essa finalidade é \textit{AEGIS Ontology} \citep{aegis:13},
que define ontologias de acessibilidade na \textit{Web}. O principal objetivo do
projeto é mapear os conceitos de acessibilidade, e como eles podem ser mapeados
dentro de um cenário de acessibilidade.

O projeto é apoiado pelo \textit{Accessible Consortium} \citep{accessibleconsortium:13}, que
disponibiliza uma página para a consulta das novidades da iniciativa \citep{accessibleontology:13}.
A versão atual é a 5.1

As ontologias são descritas no formato \gls{owl}, padrão definido pela \gls{w3c}
em 2004 \citep{owl:13}, que está na versão 1.0
mas já possui uma versão candidata à 2.0, lançada em 2012 \citep{owl2draft:13}. As
ontologias descritas estão no padrão 1.0.

O projeto vai além de realizar o mapeamento dos conceitos de acessibilidade e
cenários. Os arquivos disponibilizados mapeam o modelo WCAG 2.0 (incluindo
técnicas de implementação, critérios de sucesso e falha, etc), leitores de tela,
navegadores textuais, lentes de aumento, WAI/ARIA, entre outros. É possível
navegar pelas ontologias via navegador
\footnote{http://160.40.50.89/Accessible\_Ontology/Version5.1/AccessibleOntologyOWLDoc/index.html},
ou explorar os arquivos confortavelmente através do software \textit{Protegé}
\citep{Noy01creatingsemantic}.

A ferramenta construída utilizou as ontologias definidas por este projeto, onde
será explicado com mais detalhes como elas serão utilizadas.

Ao final deste subprocesso, a ferramenta \gls{case} já deve ter as associações dos requisitos de acessibilidade com os
itens de interface e navegação (já incluindo a associação com o WCAG 2.0), bem como os outros artefatos modelados 
no subprocesso anterior. A matriz de rastreabilidade pode ser gerada novamente,
dessa vez mais completa, pois mais dados estão disponíveis neste ponto do
processo.

\section{Subprocesso 6 - Construção do Software}

 O objetivo do subprocesso 6 é produzir unidades de software executáveis que
 apropriadamente refletem o projeto de software \citep{maia:10}.
 
 O MTA insere quatro tarefas de acessibilidade, conforme mostrado na Figura
\ref{fig:sub6}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth,height=350px]{./images/subprocesso6.png}
\caption{Tarefas para o subprocesso de construção do software \citep{maia:10}}
\label{fig:sub6}
\end{figure}

A tarefa 6.1 (Especificar Técnicas para Implementação da Acessibilidade da
Interface e do Código) visa explicitar as técnicas de implementação de
acessibilidade, refletidas no projeto de software. Como dito anteriormente, o
padrão de conformidade já deve ter sido escolhido no subprocesso 1. Apesar dos padrões
de acessibilidade serem diferentes em essência, existe uma grande intersecção no que se
refere as técnicas utilizadas para implementação efetiva da acessibilidade no produto.
As regras para implementação do padrão e-Mag 3.0 são muito parecidas com as do padrão WCAG 2.0,
e a tendência é que haja uma homogeneização dos esforços em desenvolver produtos acessíveis, principalmente
como a evolução do \gls{html} 5. 

Os modelos WCAG 2.0 e e-Mag 3.0 já possuem técnicas de acessibilidade presentes
em seus respectivos documentos. Esse é o momento de relacionar as
especificidades do projeto de software com as técnicas de acessibilidade do modelo escolhido. Caso nenhum
modelo conhecido ou algum modelo não usual tenha sido escolhido, as técnicas de
implementação de acessibilidade deverão ser explicitamente relacionadas no
projeto, e, para isso, é fundamental o auxílio de um especialista em
acessibilidade.

Por conveniência, as técnicas utilizadas serão as do WCAG 2.0, pelo fato de já estarem mapeadas nos arquivos
\gls{owl} descritos anteriormente.

Devido ao escopo do trabalho, apesar serem extremamente importantes, as tarefas
\textbf{Planejar teste de acessibilidade para cada unidade de software} e
\textbf{Executar teste de acessibilidade de cada unidade de software} não foram
consideradas.

A tarefa 6.2 (Codificar e documentar cada unidade de software de acordo com as
técnicas de acessibilidade) recebe benefícios diretos dos passos anteriores,
pois o projeto já contém os pontos críticos de acessibilidade explicitados. 
Ferramentas \gls{case}, neste ponto, comumente geram código
(\textit{stub}), utilizando artefatos como diagramas de classe, de sequência e casos de uso. O código
gerado já poderia conter traços de documentação associados aos requisitos de acessibilidade.
Uma maneira imediata de documentar código é adicionando comentários padronizados, de forma que os requisitos
de acessibilidade possam ser localizados. Dependendo da linguagem de programação
utilizada, podem ser utilizadas anotações para referenciar os modelos (a
linguagem \textit{Java} permite o uso de anotações), mas esta abordagem não
será utilizada neste trabalho.

Para incorporar a rastreabilidade
dos requisitos no código gerado pelas ferramentas em forma de comentário de código, temos as seguintes abordagens:

\begin{enumerate}
  \item A ferramenta de modelagem gera os códigos, e posteriormente, a
  ferramenta \gls{case} proposta incluiria os comentários de rastreabilidade;
  \item A ferramenta \gls{case} proposta substituiria o gerador de código,
  realizando todo o trabalho e gerando o código já comentado.
  \item O gerador de código é customizado para que gere o código e os
  comentários personalizados no mesmo instante.
\end{enumerate}

A primeira abordagem implica em avaliar todo os arquivos \textit{Java} para
encontrar o local exato onde o comentário deve ser posicionado. Além de ser
necessário construir um \textit{parser} complexo para essa situação, pode ser
difícil encontrar o caminho de retorno (código \textit{Java} para o modelo
\gls{uml}) desta forma.

A segunda abordagem implica na construção total de uma ferramenta complexa que
está fora do escopo deste trabalho.

A terceira abordagem, que por sua vez foi a escolhida, foi customizar o gerador
de código, pois o código fonte deste gerador estava disponível e, devido ao fato do gerador de código usar
\textit{templates} de construção. Desta forma, as intervenções na ferramenta
foram mínimas, e pouco código adicional precisou ser incorporado.

\section{Escolha das Ferramentas e Tecnologias}

A proposta deste trabalho é demonstrar a rastreabilidade dos requisitos de
acessibilidade no processo de desenvolvimento de \textit{software},
independente de ferramenta ou tecnologia adotada pelos analistas e
desenvolvedores.

Já existem iniciativas, principalmente corporativas, que permitem agregar os
requisitos levantados aos artefatos do processo de desenvolvimento.
\citet{hovater:08} mostra como construir relatórios de rastreabilidade usando os
programas \textit{IBM Rational Software Architect} \citep{ibm:13},
\textit{IBM Rational RequisitePro} \citep{ibmreq:13} e \gls{birt}
para \textit{WebSphere} \citep{ibmwebsphere:13}.

O software \textit{Enterprise Architect} da empresa \textit{Sparx Systems}
\citep{sparx:13} permite utilizar diagramas de
requisitos\footnote{http://www.sparxsystems.com/enterprise\_architect\_user\_guide/modeling\_languages/requirements\_diagram.html}, que são extensões dos diagramas tradicionais da \gls{uml}, permitindo a
rastreabilidade do
modelo\footnote{http://www.sparxsystems.com/enterprise\_architect\_user\_guide/navigate\_search\_and\_trace/traceability.html}.
Contudo, não foi encontrado na literatura trabalhos que tratem especificamente da rastreabilidade dos requisitos de acessibilidade dentro do processo de um
desenvolvimento de \textit{software}.

Dessa forma, para demonstrar a proposta deste trabalho, será construída uma
ferramenta \gls{case}, nos moldes descritos na seção \ref{linktocase}. A seguir
é elencado os principais elementos usados para a demostração deste trabalho.

\begin{itemize}
  \item \gls{mta} - Processo de Desenvolvimento de \textit{Software} com tarefas
  de acessibilidade
  \item \textit{Eclipse Juno} - \gls{ide}
  \item \textit{Requirement Designer v0.8.0} \citep{reqdesigner:13} - 
  \textit{plugin} de gerenciamento de
  requisitos
  \item \textit{UML Designer v2.1.0} \citep{umldesigner:13} - 
  \textit{plugin} de modelagem \gls{uml}
  \item \textit{UML to Java Generator v1.0.2} \citep{umltojava:13} - 
  \textit{plugin} de geração de código 
  \item \textit{Java JRE7 e JDK1.7} \citep{java:13} 
  - Linguagem para desenvolvimento de \textit{plugins} e código final do produto
  \item Ontologias para implementação das diretrizes do \gls{wcag} 2.0.
\end{itemize}

O \textit{Eclipse} é uma plataforma madura e foi escolhido como \gls{ide} por
vários motivos. Ele serve como base para para diversos produtos e tecnologias baseadas em uma \gls{ide},
provendo uma \gls{api} para facilitar a integração \citep{5386785}.
O desenvolvimento de \textit{plugins} para o \textit{Eclipse} é feito diretamente na \gls{ide}, de forma prática e 
transparente\footnote{Um tutorial de desenvolvimento de plugins para o Eclipse
pode ser encontrado em http://www.ibm.com/developerworks/br/library/os-ecplug/}, tendo ampla documentação a respeito. 
A linguagem utilizada para o desenvolvimento do \textit{plugin} é linguagem \textit{Java}, assim como o código gerado 
pelo \textit{plugin} de exportação.

O pacote de modelagem inicialmente instalado foram os \textit{plugins} \gls{emf} propostos pelo \textit{Eclipse}, notadamente
o \textit{Ecore Tools} \citep{ecoretools:13}, parte integrante do \gls{emft}. Contudo,
os diagramas fornecidos por \textit{default} não satisfizeram aos anseios de modelagem, pois não contemplavam diagramas de sequência ou de 
casos de uso, por exemplo. Por esse motivo, o \textit{plugin} escolhido foi o \textit{UML Designer}, que utiliza como base o pacote \gls{emf} (portanto gera modelos \gls{emf}), 
mas extende os modelos existentes para que se adequem aos modelos \gls{uml} na sua versão 2.4. 

O \textit{plugin} inicialmente escolhido para o gerenciamento de requisitos foi
o \textit{ProR} \citep{rmf:13}, que por sua vez é parte do projeto \gls{rmf} e
\gls{emf} do
\textit{Eclipse}. O objetivo do projeto \gls{rmf} é implementar o padrão
\textit{OMG ReqIF} \citep{reqif:13} em forma de modelos \gls{emf}. Contudo, o
\gls{rmf} se encontra atualmente na 0.7.1 e o \textit{plugin} não fornecia a funcionalidade de ligação entre os
modelos e os requisitos. Assim, modos alternativos de relacionamento entre os modelos e os requisitos deveriam ser implementados, tornando inviável o desenvolvimento do trabalho. Portanto, o \textit{plugin} escolhido para o gerenciamento
de requisitos foi o \textit{Requirement Designer}, que permite realizar a associação dos requisitos com qualquer modelo \gls{emf}.

Os \textit{plugins} de modelagem e gerenciamento de requisitos são desenvolvidos
pela \textit{Obeo} \citep{obeo:13}, portanto, para permitir uma integração suave entre
as ferramentas, o \textit{plugin} escolhido para geração de código foi o \textit{UML to Java Generator}, desenvolvido pela mesma empresa. Os \textit{plugins} são disponibilizados sob a licença \textit{Eclipse Public License v
1.0} \citep{eclipselicense:13}, assim como a própria \gls{ide}. Dessa forma, é possível
estudar, alterar e customizar seus componentes para atingir aos objetivos do trabalho.

A Figura \ref{fig:association} mostra o comportamento e relacionamento das
ferramentas, tecnologias e atores envolvidos no desenvolvimento do produto, que
deve ser interpretada da seguinte forma:

\begin{itemize}
  \item O \gls{mta} é o processo de desenvolvimento, e deve permear todas as
  fases do processo;
  \item O especialista em acessibilidade (\textit{Accessibility Expert}) deve
  participar das fases de desenvolvimento especificadas no \gls{mta};
  \item Os requisitos devem ser coletados e informados na fase de engenharia de
  requisitos (utilizando a ferramenta \textit{Requirement
  Designer}), e os modelos e artefatos \gls{uml} devem ser gerados (utilizando a
  ferramenta \textit{UML Designer}) O especialista em acessibilidade deve
  auxiliar a alimentação destes dados, filtrando os requisitos de acessibilidade para que eles sejam
  associados aos modelos \gls{uml} (utilizando a ferramenta
  \textit{Requirement Designer});
  \item A ferramenta proposta recupera as associações dos requisitos e modelos
  \gls{uml} (apenas aos que dizem respeito à acessibilidade), permitindo que o
  especialista especifique as técnicas de implementações de acessibilidade para
  cada uma das associações. As técnicas, diretrizes, abordagens e o que mais
  dizer respeito a implementação técnica da associação estão armazenadas em
  arquivos \gls{owl} embutidos na ferramenta;
  \item A ferramenta de geração de código produzirá o código \textit{stub} a
  partir dos modelos \gls{uml}, adicionando as referências às associações de
  acessibilidade quando necessário;
  \item O(s) desenvolvedor(res) refinam o código até que o mesmo esteja apto a
  se tornar o produto acessível que será entregue.
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/developmentNew.png}
\caption{Associação das ferramentas e atores no contexto to trabalho}
\label{fig:association}
\end{figure}

\section{Construção da Ferramenta}

O \textit{plugin} construído utiliza quatro elementos externos que precisam ser
detalhados:

\begin{itemize}
  \item O repositório dos requisitos
  \item O requisito
  \item O modelo \gls{uml}
  \item A técnica de acessibilidade, representado pela ontologia
\end{itemize}

A Figura \ref{fig:reqdesignerexample} mostra a execução da ferramenta
\textit{Requirement Designer} e o cadastro de algumas categorias e requisitos
como exemplo.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/requirementDesignerExample.png}
\caption{Execução da ferramenta \textit{Requirement Designer}}
\label{fig:reqdesignerexample}
\end{figure}

O diagrama de classes visualizado na Figura \ref{fig:reqdesigner_classdiagram}
demonstra o núcleo de funcionamento do \textit{plugin Requirement Designer},
que possui os dois primeiros elementos listados anteriormente.
Existe um repositório (\textit{Repository}), que pode conter zero ou mais
categorias principais (\textit{Category}). Cada categoria principal pode conter
0 ou mais requisitos (\textit{Requirement}), e também pode conter 0 ou mais
subcategorias (\textit{Category}), recursivamente. Os requisitos podem ser do
tipo funcionais ou não-funcionais (neste \textit{plugin} tratados como
requisitos técnicos).

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/requirement_package_entities.png}
\caption{Diagrama de classes do \textit{plugin} Requirement Designer}
\label{fig:reqdesigner_classdiagram}
\end{figure}

O diagrama de classes foi gerado usando o \gls{emf} (especificamente a
ferramentas \textit{Ecore Model}), resultando nas classes java representativas
do modelo (usando a ferramenta de transformação \textit{Ecore Generator Model}).
Na prática, significa dizer que, uma vez tendo o diagrama de classes no modelo
\textit{Ecore}, seja possível utilizar as classes java resultantes e,
principalmente, que o arquivo de saída da ferramenta \textit{Requirement
Designer} possa ser lido e interpretado de forma simplificada como os objetos
corretos do \textit{plugin}.

A ferramenta para gerar os artefatos \gls{uml} é a \textit{UML Designer}. A
ferramenta usa a \gls{api} do \textit{Eclipse (org.eclipse.uml2.uml)}, que por
sua vez é persistida usando \gls{emf}. Por esse motivo, a ferramenta de
gerenciamento de requisitos consegue gerar uma associação entre os requisitos e
qualquer elemento presente na \gls{api}.

A Figura \ref{fig:usecaseexample} mostra um diagrama de casos de uso de exemplo
gerado pela ferramenta \textit{UML Designer}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/usecaseexample.png}
\caption{Exemplo de um diagrama de casos de uso gerado pela ferramenta
\textit{UML Designer}}
\label{fig:usecaseexample}
\end{figure}

A ferramenta \textit{Requirement Designer} utiliza referências \gls{emf}
(elementos \textit{proxy}) para associar os modelos \gls{uml} gerados pela
ferramenta \textit{UML Designer}, significando que os objetos referenciados não
são escritos no arquivo \gls{xml} de destino. Assim, o modelo pode ser alterado,
e o objeto sempre estará atualizado no arquivo referenciado. Essa mesma técnica
será usada no modelo de dados a ser construído pela ferramenta proposta, com
exceção dos objetos referentes às ontologias de acessibilidade.

As ontologias de acessibilidade são descritas no padrão \gls{owl}, que tem por
base o formato \gls{rdf}. Para efetuar a leitura dos arquivos \gls{owl},
utilizamos a \textit{OWL API}, que por sua vez é utilizado pelo
\textit{software Protégé}, \textit{software} este muito útil para visualizar de
forma gráfica os elementos e relacionamentos descritos nas ontologias. Este
\textit{software} foi usado diversas vezes para descobrir quais os elementos da
ontologia e como eles deveriam ser acessados através da api. A figura
\ref{fig:protege} mostra um dos arquivos de ontologias usados no trabalho aberto
para consulta.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/protege.png}
\caption{Exemplo do arquivo WCAG2.owl aberto no \textit{software Protégé}}
\label{fig:protege}
\end{figure}

Diante do exposto, é possível apresentar o diagrama de classes da ferramenta
proposta, aqui denominada como \textit{AccTrace}, visível na Figura
\ref{fig:acctraceclassdiagram}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/acctraceclassdiagram.png}
\caption{Diagrama de classes da ferramenta proposta (\textit{AccTrace})}
\label{fig:acctraceclassdiagram}
\end{figure}

O diagrama de classes deve ser interpretado da seguinte forma: A classe
principal é a \textit{AccTraceModel}, que armazena as referências para os
repositórios dos requisitos (\textit{Repository}), e também objetos de
referência às associações dos requisitos, modelos e técnicas
de implementação de acessibilidade (\textit{Reference}). Esse objeto referencia
um requisito (\textit{Requirement}), um diagrama \gls{uml} (\textit{EObject}) e
1 ou mais técnicas de implementação de acessibilidade, representadas aqui pela
seleção das ontologias disponíveis. As referências às ontologias são persistidas
através de suas \gls{iri} (uma generalização de \gls{uri}) em forma de \textit{String}.
Além disso, devido ao grande número de requisitos possíveis no projeto e
considerando o fato de que apenas os requisitos de acessibilidade sejam
importantes para a associação à técnicas de implementação de acessibilidade, é previsto no modelo também a inclusão de filtros dos requisitos (\textit{RequirementFilter}), para não poluir a
visualização dos requisitos na ferramenta.

A ferramenta possui três visões principais, de acordo com a Figura
\ref{fig:acctrace}: o editor (\textit{AccTrace Editor}), onde é possível alterar
os repositórios dos requisitos e gerar as associações entre os modelos
\gls{uml}, requisitos e técnicas de implementação; a visão dos requisitos
(\textit{Requirement Associations}), onde é possível visualizar quais os
requisitos associados ao modelo \gls{uml} selecionado no editor; e a visão das
técnicas já implementadas (\textit{Accessibility Specifications View}), onde é
possível visualizar as técnicas de implementação já associadas, de acordo com o
modelo \gls{uml} selecionado no editor e o requisito de acessibilidade
selecionado na visão dos requisitos, bem como remover as técnicas de
implementação associadas. As três visões são importantes para o correto
funcionamento da ferramenta.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/acctrace.png}
\caption{Visualização da ferramenta \textit{AccTrace} na tela principal do
\textit{Eclipse}}
\label{fig:acctrace}
\end{figure}

Uma vez selecionado o modelo \gls{uml} e o requisito, é possível efetuar a
associação da técnica de implementação de acessibilidade, clicando com o botão
direito do mouse em cima do modelo \gls{uml}, conforme demonstrado na Figura
\ref{fig:rightclick}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/rightclick.png}
\caption{Procedimento para efetuar a associação da técnica de implementação de
acessibilidade}
\label{fig:rightclick}
\end{figure}

O menu mostrado na Figura foi projetado levando em conta
a análise e estudo das ontologias disponíveis, efetuados na ferramenta
\textit{Protégé}. É possível entender o relacionamento dos elementos e
ontologias observando a Figura \ref{fig:ontologyrelationship}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/ontologyrelationship.png}
\caption{Relacionamento entre as ontologias}
\label{fig:ontologyrelationship}
\end{figure}

Para este trabalho, uma das ontologias mais importantes é a ontologia denominada
\textit{WCAG 2.0}, pois é esta ontologia que comporta as técnicas de
implementação de acessibilidade que efetivamente serão utilizadas. As outras
ontologias, apesar de acessórias, podem ser utilizadas para reforçar as técnicas
já referenciadas. 

A ontologia \textit{WCAG 2.0} possui 5 grupos a serem escolhidos, conforme
mostra a Figura \ref{fig:wcag2groups}: abordagens, testes, critérios de
sucesso, diretrizes ou técnicas. Cada um desses grupos contém os elementos que
efetivamente devem ser selecionados para que a associação seja concluída.
Tomando como base a escolha do subgrupo critérios de sucesso, podemos ver as
opções disponíveis mostradas na Figura \ref{fig:successcriterion}. Os elementos
internos das ontologias são diferentes, dependendo qual seu tipo e objetivo. A
Figura \ref{fig:successcriterion127} mostra quais os elementos da ontologia
escolhida como exemplo (\textit{WCAG2 SuccessCriterion 1.2.7}):
ela possui uma descrição, uma prioridade, um ID e um nome, além de
relacionamentos com outras ontologias que aqui foram omitidas. Uma vez
selecionada a ontologia apropriada, um clique no botão OK faz com que a
associação seja persistida ao modelo.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/wcag2groups.png}
\caption{Grupos a serem selecionados a partir da ontologia \textit{WCAG 2.0}}
\label{fig:wcag2groups}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/successcriterion.png}
\caption{Elementos disponíveis para a ontologia \textit{SuccessCriterion}}
\label{fig:successcriterion}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/successcriterion127.png}
\caption{Seleção da ontologia \textit{WCAG2 SuccessCriterion 1.2.7}}
\label{fig:successcriterion127}
\end{figure}

É possível rastrear os requisitos, modelos \gls{uml} e técnicas de implementação
através da geração de uma matriz de rastreabilidade. Neste trabalho foi
utilizado o \textit{Apache ODF
Toolkit} \citep{odftoolkit:13} para geração do
documento de rastreamento com formato \gls{ods}, através da \gls{api} de alto
nível
\textit{Simple} \citep{odftoolkitsimple:13}.
No documento, são geradas três planilhas: Requerimentos x Modelos, Requerimentos
x Técnicas e Modelos x Técnicas. A planilha Requerimentos x Modelos lista uma
matriz de todos os requerimentos associados aos respectivos modelos, mesmo que
exista algum requerimento que não esteja associado a algum modelo. Essa situação
está prevista justamente para identificar problemas na associação que devam ser
corrigidas. Para as planilhas Requerimentos x Técnicas e Modelos x Técnicas,
apenas os objetos que estão efetivamente referenciados na ferramenta são
listados.

A Figura \ref{fig:matrixpart} mostra uma parte da matriz de rastreabilidade
gerada pela ferramenta. A matriz deve ser gerada utilizando o \textit{wizard}
específico para esse fim, acessando na barra de tarefas as opções \textit{File
$>$ New $>$ Other\ldots} e selecionando a opção \textit{Traceability Matrix file
wizard}. Para a geração da matriz ocorrer sem erros, é necessário informar o
arquivo que armazena o modelo da ferramenta, com a extensão .acctrace.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/matrixpart.png}
\caption{Parte da matriz de rastreabilidade gerada pela ferramenta}
\label{fig:matrixpart}
\end{figure}

Para geração de código, utilizamos o \textit{plugin \gls{uml} to Java
Generator}, que por sua vez utiliza o ponto de extensão do \textit{plugin
Acceleo} \citep{acceleo:13}. O \textit{plugin
Acceleo} tem por finalidade transformar os modelos \gls{emf} em uma linguagem
definida pelo usuário, através de arquivos com a extensão .mtl (\textit{Model
to Text Language}). Os arquivos .mtl possuem uma sintaxe própria, que pode ser
vista no trecho de código mostrado a seguir.

\begin{verbatim}
[comment encoding = UTF-8 /]
[module classifierJavaFile('http://www.eclipse.org/uml2/4.0.0/UML')]

[import org::obeonetwork::pim::uml2::gen::java::common::documentation /]
[import org::obeonetwork::pim::uml2::gen::java::common::path /]

[import org::obeonetwork::pim::uml2::gen::java::services::importService /]

[template private classifierJavaFilePath(aClassifier : Classifier)]
[if (not aClassifier.getNearestPackage().oclIsUndefined())]
[aClassifier.genPackagePath()/][aClassifier.name/].java
[else]
[aClassifier.name.concat('.java')/]
[/if]
[/template]
\end{verbatim}

Enquanto o \textit{Acceleo} tem por finalidade transformar modelos \gls{emf} em
uma linguagem pré-definida pelo usuário, o plugin \textit{\gls{uml} to Java
Generator} tem a finalidade específica de transformar modelos \gls{uml}
(persistidos como modelos \gls{emf}) em linguagem \textit{Java}. Ele não gera
apenas código \textit{Java}, mas o projeto inteiro no \textit{Eclipse}, criando
as pastas, arquivos de configuração, informações de importação e exportação,
ambiente de execução alvo, entre outros. Por este motivo também, o
\textit{plugin} \textit{\gls{uml} to Java
Generator} é bastante simples. As partes principais do \textit{plugin} são:

\begin{itemize}
  \item a \gls{ui},
especificando opções de configuração, como modelo \gls{uml} a ser utilizado, ambiente de execução
alvo, entre outras opções;
  \item as classes de lançamento do \textit{plugin Acceleo}, utilizando as
  informações da \gls{ui};
  \item os arquivos .mtl que descrevem como os modelos devem ser gerados, no
  caso, as informação de geraçãos dos arquivos \textit{Java} e do projeto
  \textit{Eclipse}.
\end{itemize} 

As alterações necessárias para que o \textit{plugin \gls{uml} to Java Generator}
gerasse os comentários personalizados do modelo \textit{AccTrace} foram:

\begin{enumerate}
  \item alteração da \gls{ui}, para que fosse possível indicar o arquivo
  .acctrace;
  \item intervenção nas classes de lançamento, para que o arquivo .acctrace
  fosse corretamente carregado e recuperado quando necessário;
  \item alteração dos arquivos .mtl necessários para que o código \textit{Java}
  gerado incluísse o(s) comentário(s) do modelo \textit{AccTrace}, se houver uma
  referência para o elemento \gls{uml} avaliado no momento.
\end{enumerate}

O comentário \textit{AccTrace} é recuperado usando \textit{query
invoke} \citep{acceleoquery:13}, um
mecanismo utilizado pelo \textit{plugin Acceleo} que encapsula dentro dos
arquivos .mtl chamadas nativas a funções \textit{Java}. O \textit{query invoke}
usado foi incluído no arquivo
\textit{org.obeonetwork.pim.uml2.gen.java.services.typesServices.mtl} e é
descrito a seguir.

\begin{verbatim}
[query public getComment(anOclAny : OclAny) : String
	= invoke('org.obeonetwork.pim.uml2.gen.java.services.AccTraceServices', 
	'getComment(org.eclipse.emf.ecore.EObject)', Sequence{anOclAny}) /]
\end{verbatim}

No momento desejado (por exemplo, logo após a construção da especificação de
uma classe ou interface) o \textit{query invoke} é chamado, passando como
argumento o objeto \gls{uml} avaliado no momento. Na classe \textit{Java
AccTraceServices} existe um método \textit{getComment} que recebe como argumento
um objeto \textit{EObject}, ou seja, qualquer elemento \gls{emf}. Neste método,
é verificado se o modelo \textit{AccTrace} foi especificado (em caso negativo,
nada é retornado). Logo em seguida, é verificado se no modelo \textit{AccTrace}
existe uma referência ao elemento \gls{uml} avaliado (significando que existe
uma associação entre um requisito, modelo e técnicas), e em caso positivo, o
comentário é construído e retornado, sendo incluído no corpo do código
\textit{Java}. Caso o elemento \gls{uml} não seja encontrado no modelo, uma
\textit{String} vazia é retornada.

O comentário \textit{AccTrace} é construído utilizando a seguinte expressão
regular \textit{Java}:

\begin{verbatim}
String regex = "//!ACCTRACE!(/)?([^/\\\\0#]+(/)?)+#([^\\*\\*/])+";
\end{verbatim}

A opção de se utilizar um comentário de linha (ao invés de comentários de
bloco, usados por exemplo pela documentação \textit{JavaDoc}) decorreu do fato
do comentário descrito ser incluído dentro do corpo da classe e métodos, e caso
o programador decida comentar o trecho de código inteiro, esse comentário não
atrapalharia essa operação.

Uma vez tendo os comentários personalizados nos código-fonte Java, o \textit{plugin AccTrace} se encarrega de verificar os comentários
para traduzí-los em informações úteis ao desenvolvedor. O \textit{plugin} usa o ponto de extensão \textit{Compilation Participant} da biblioteca \gls{jdt},
usado para acompanhar e recuperar informações úteis no processo de compilação do código. No caso deste trabalho, 
o ambiente entrega a \gls{ast} do modelo Java, e partir dele os comentários são extraídos. Caso o comentário 
atenda à expressão regular de comentário do \textit{plugin AccTrace}, uma marca (\textit{marker}) é adicionada 
ao editor, indicando que naquele ponto há um comentário válido. A marca replica o comentário, de modo que ao 
passsar o mouse sobre a marca, um \textit{popup} surge, conforme mostrado pela
Figura \ref{fig:acctracecomment}.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/acctracecomment.png}
\caption{Comentário padrão AccTrace demonstrado utilizando o evento
\textit{mouse hover}}
\label{fig:acctracecomment}
\end{figure}

Ao clicar na marca, uma visão é notificada para que o conteúdo do comentário
seja traduzido. A Figura \ref{fig:commentview} mostra um comentário já
traduzido, onde se pode observar informações como requisito, modelo \gls{uml} e
quais técnicas estão referenciadas por aquele comentário. A Figura
\ref{fig:commentrecovery} mostra como recuperar as informações relevantes
partindo de um comentário no formato AccTrace. O comentário passa por um
\textit{Regex Match}, sendo decomposto em:

\begin{itemize}
  \item Caminho relativo do arquivo do modelo AccTrace no \textit{workspace} do
  \textit{Eclipse};
  \item Referência (ID) da associação dentro do modelo;
\end{itemize}

O modelo AccTrace é carregado através do caminho encontrado e logo em seguida a
referência da associação é recuperada do modelo, usando seu ID como parâmetro de
busca. A partir da refência é possível recuperar o Requisito, o Modelo UML e as
técnicas de implementação de acessibilidade. Como no modelo AccTrace apenas as
referência aos objetos é armazenada, qualquer mudança nos objetos envolvidas é
vista em tempo real. A atualização da tela da visão pode não ser
instantânea, dependendo da complexidade dos objetos envolvidos e da quantidade
de recursos que devem ser recuperados.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/commentview.png}
\caption{Visão de explicitação do comentário selecionado.}
\label{fig:commentview}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./images/commentrecovery.png}
\caption{Passos para recuperação das informações relevantes através de um
comentário padrão AccTrace}
\label{fig:commentrecovery}
\end{figure}

